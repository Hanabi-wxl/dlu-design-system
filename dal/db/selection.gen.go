// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package db

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/Hanabi-wxl/dlu-design-system/dal/model"
)

func newSelection(db *gorm.DB, opts ...gen.DOOption) selection {
	_selection := selection{}

	_selection.selectionDo.UseDB(db, opts...)
	_selection.selectionDo.UseModel(&model.Selection{})

	tableName := _selection.selectionDo.TableName()
	_selection.ALL = field.NewAsterisk(tableName)
	_selection.ID = field.NewInt64(tableName, "id")
	_selection.StudentID = field.NewInt64(tableName, "student_id")
	_selection.Attribute72 = field.NewInt64(tableName, "Attribute_72")
	_selection.SubjectSecondID = field.NewInt64(tableName, "subject_second_id")
	_selection.FirstChangeCount = field.NewInt64(tableName, "first_change_count")
	_selection.SecondChangeCount = field.NewInt64(tableName, "second_change_count")

	_selection.fillFieldMap()

	return _selection
}

type selection struct {
	selectionDo

	ALL               field.Asterisk
	ID                field.Int64 // id
	StudentID         field.Int64 // 学生id
	Attribute72       field.Int64 // 第一志愿题目id
	SubjectSecondID   field.Int64 // 第二志愿题目id
	FirstChangeCount  field.Int64 // 第一志愿修改次数
	SecondChangeCount field.Int64 // 第二志愿修改次数

	fieldMap map[string]field.Expr
}

func (s selection) Table(newTableName string) *selection {
	s.selectionDo.UseTable(newTableName)
	return s.updateTableName(newTableName)
}

func (s selection) As(alias string) *selection {
	s.selectionDo.DO = *(s.selectionDo.As(alias).(*gen.DO))
	return s.updateTableName(alias)
}

func (s *selection) updateTableName(table string) *selection {
	s.ALL = field.NewAsterisk(table)
	s.ID = field.NewInt64(table, "id")
	s.StudentID = field.NewInt64(table, "student_id")
	s.Attribute72 = field.NewInt64(table, "Attribute_72")
	s.SubjectSecondID = field.NewInt64(table, "subject_second_id")
	s.FirstChangeCount = field.NewInt64(table, "first_change_count")
	s.SecondChangeCount = field.NewInt64(table, "second_change_count")

	s.fillFieldMap()

	return s
}

func (s *selection) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := s.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (s *selection) fillFieldMap() {
	s.fieldMap = make(map[string]field.Expr, 6)
	s.fieldMap["id"] = s.ID
	s.fieldMap["student_id"] = s.StudentID
	s.fieldMap["Attribute_72"] = s.Attribute72
	s.fieldMap["subject_second_id"] = s.SubjectSecondID
	s.fieldMap["first_change_count"] = s.FirstChangeCount
	s.fieldMap["second_change_count"] = s.SecondChangeCount
}

func (s selection) clone(db *gorm.DB) selection {
	s.selectionDo.ReplaceConnPool(db.Statement.ConnPool)
	return s
}

func (s selection) replaceDB(db *gorm.DB) selection {
	s.selectionDo.ReplaceDB(db)
	return s
}

type selectionDo struct{ gen.DO }

type ISelectionDo interface {
	gen.SubQuery
	Debug() ISelectionDo
	WithContext(ctx context.Context) ISelectionDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ISelectionDo
	WriteDB() ISelectionDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ISelectionDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ISelectionDo
	Not(conds ...gen.Condition) ISelectionDo
	Or(conds ...gen.Condition) ISelectionDo
	Select(conds ...field.Expr) ISelectionDo
	Where(conds ...gen.Condition) ISelectionDo
	Order(conds ...field.Expr) ISelectionDo
	Distinct(cols ...field.Expr) ISelectionDo
	Omit(cols ...field.Expr) ISelectionDo
	Join(table schema.Tabler, on ...field.Expr) ISelectionDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ISelectionDo
	RightJoin(table schema.Tabler, on ...field.Expr) ISelectionDo
	Group(cols ...field.Expr) ISelectionDo
	Having(conds ...gen.Condition) ISelectionDo
	Limit(limit int) ISelectionDo
	Offset(offset int) ISelectionDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ISelectionDo
	Unscoped() ISelectionDo
	Create(values ...*model.Selection) error
	CreateInBatches(values []*model.Selection, batchSize int) error
	Save(values ...*model.Selection) error
	First() (*model.Selection, error)
	Take() (*model.Selection, error)
	Last() (*model.Selection, error)
	Find() ([]*model.Selection, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.Selection, err error)
	FindInBatches(result *[]*model.Selection, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.Selection) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ISelectionDo
	Assign(attrs ...field.AssignExpr) ISelectionDo
	Joins(fields ...field.RelationField) ISelectionDo
	Preload(fields ...field.RelationField) ISelectionDo
	FirstOrInit() (*model.Selection, error)
	FirstOrCreate() (*model.Selection, error)
	FindByPage(offset int, limit int) (result []*model.Selection, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ISelectionDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (s selectionDo) Debug() ISelectionDo {
	return s.withDO(s.DO.Debug())
}

func (s selectionDo) WithContext(ctx context.Context) ISelectionDo {
	return s.withDO(s.DO.WithContext(ctx))
}

func (s selectionDo) ReadDB() ISelectionDo {
	return s.Clauses(dbresolver.Read)
}

func (s selectionDo) WriteDB() ISelectionDo {
	return s.Clauses(dbresolver.Write)
}

func (s selectionDo) Session(config *gorm.Session) ISelectionDo {
	return s.withDO(s.DO.Session(config))
}

func (s selectionDo) Clauses(conds ...clause.Expression) ISelectionDo {
	return s.withDO(s.DO.Clauses(conds...))
}

func (s selectionDo) Returning(value interface{}, columns ...string) ISelectionDo {
	return s.withDO(s.DO.Returning(value, columns...))
}

func (s selectionDo) Not(conds ...gen.Condition) ISelectionDo {
	return s.withDO(s.DO.Not(conds...))
}

func (s selectionDo) Or(conds ...gen.Condition) ISelectionDo {
	return s.withDO(s.DO.Or(conds...))
}

func (s selectionDo) Select(conds ...field.Expr) ISelectionDo {
	return s.withDO(s.DO.Select(conds...))
}

func (s selectionDo) Where(conds ...gen.Condition) ISelectionDo {
	return s.withDO(s.DO.Where(conds...))
}

func (s selectionDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) ISelectionDo {
	return s.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (s selectionDo) Order(conds ...field.Expr) ISelectionDo {
	return s.withDO(s.DO.Order(conds...))
}

func (s selectionDo) Distinct(cols ...field.Expr) ISelectionDo {
	return s.withDO(s.DO.Distinct(cols...))
}

func (s selectionDo) Omit(cols ...field.Expr) ISelectionDo {
	return s.withDO(s.DO.Omit(cols...))
}

func (s selectionDo) Join(table schema.Tabler, on ...field.Expr) ISelectionDo {
	return s.withDO(s.DO.Join(table, on...))
}

func (s selectionDo) LeftJoin(table schema.Tabler, on ...field.Expr) ISelectionDo {
	return s.withDO(s.DO.LeftJoin(table, on...))
}

func (s selectionDo) RightJoin(table schema.Tabler, on ...field.Expr) ISelectionDo {
	return s.withDO(s.DO.RightJoin(table, on...))
}

func (s selectionDo) Group(cols ...field.Expr) ISelectionDo {
	return s.withDO(s.DO.Group(cols...))
}

func (s selectionDo) Having(conds ...gen.Condition) ISelectionDo {
	return s.withDO(s.DO.Having(conds...))
}

func (s selectionDo) Limit(limit int) ISelectionDo {
	return s.withDO(s.DO.Limit(limit))
}

func (s selectionDo) Offset(offset int) ISelectionDo {
	return s.withDO(s.DO.Offset(offset))
}

func (s selectionDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ISelectionDo {
	return s.withDO(s.DO.Scopes(funcs...))
}

func (s selectionDo) Unscoped() ISelectionDo {
	return s.withDO(s.DO.Unscoped())
}

func (s selectionDo) Create(values ...*model.Selection) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Create(values)
}

func (s selectionDo) CreateInBatches(values []*model.Selection, batchSize int) error {
	return s.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (s selectionDo) Save(values ...*model.Selection) error {
	if len(values) == 0 {
		return nil
	}
	return s.DO.Save(values)
}

func (s selectionDo) First() (*model.Selection, error) {
	if result, err := s.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.Selection), nil
	}
}

func (s selectionDo) Take() (*model.Selection, error) {
	if result, err := s.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.Selection), nil
	}
}

func (s selectionDo) Last() (*model.Selection, error) {
	if result, err := s.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.Selection), nil
	}
}

func (s selectionDo) Find() ([]*model.Selection, error) {
	result, err := s.DO.Find()
	return result.([]*model.Selection), err
}

func (s selectionDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.Selection, err error) {
	buf := make([]*model.Selection, 0, batchSize)
	err = s.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (s selectionDo) FindInBatches(result *[]*model.Selection, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return s.DO.FindInBatches(result, batchSize, fc)
}

func (s selectionDo) Attrs(attrs ...field.AssignExpr) ISelectionDo {
	return s.withDO(s.DO.Attrs(attrs...))
}

func (s selectionDo) Assign(attrs ...field.AssignExpr) ISelectionDo {
	return s.withDO(s.DO.Assign(attrs...))
}

func (s selectionDo) Joins(fields ...field.RelationField) ISelectionDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Joins(_f))
	}
	return &s
}

func (s selectionDo) Preload(fields ...field.RelationField) ISelectionDo {
	for _, _f := range fields {
		s = *s.withDO(s.DO.Preload(_f))
	}
	return &s
}

func (s selectionDo) FirstOrInit() (*model.Selection, error) {
	if result, err := s.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.Selection), nil
	}
}

func (s selectionDo) FirstOrCreate() (*model.Selection, error) {
	if result, err := s.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.Selection), nil
	}
}

func (s selectionDo) FindByPage(offset int, limit int) (result []*model.Selection, count int64, err error) {
	result, err = s.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = s.Offset(-1).Limit(-1).Count()
	return
}

func (s selectionDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = s.Count()
	if err != nil {
		return
	}

	err = s.Offset(offset).Limit(limit).Scan(result)
	return
}

func (s selectionDo) Scan(result interface{}) (err error) {
	return s.DO.Scan(result)
}

func (s selectionDo) Delete(models ...*model.Selection) (result gen.ResultInfo, err error) {
	return s.DO.Delete(models)
}

func (s *selectionDo) withDO(do gen.Dao) *selectionDo {
	s.DO = *do.(*gen.DO)
	return s
}
